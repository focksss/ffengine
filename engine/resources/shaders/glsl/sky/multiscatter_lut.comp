#version 460
// per MM, as per: https://www.shadertoy.com/view/slSXRW
const float PLANET_RADIUS = 6.360;
const float ATMOSPHERE_RADIUS = 6.460;
const vec3 RAYLEIGH_SCATTERING = vec3(5.802, 13.558, 33.1);
const float RAYLEIGH_ABSORPTION = 0.0;
const float MIE_SCATTERING = 21.996;
const float MIE_ABSORPTION = 4.4;
const vec3 OZONE_ABSORPTION = vec3(0.650, 1.881, .085);



layout(local_size_x = 4, local_size_y = 4, local_size_z = 1) in;

layout(set = 0, binding = 0) uniform sampler2D transmittance_lut;
layout(set = 0, binding = 1) uniform writeonly image2D multiscatter_lut;

const float STEPS = 20.0;
const int SQRT_SAMPLES = 4;

const float PI = 3.14159265358979323846264338327950288419716939937510;

float intersect_sphere(vec3 o, vec3 d, float r) {
    float b = dot(o, d);
    float c = dot(o, o) - r*r;
    if (c > 0.0f && b > 0.0) return -1.0;
    float discr = b*b - c;
    if (discr < 0.0) return -1.0;
    if (discr > b*b) return (-b + sqrt(discr));
    return -b - sqrt(discr);
}
void get_scattering_values(
    vec3 p,
    out vec3 rayleigh_scattering,
    out float mie_scattering,
    out vec3 extinction
) {
    float altitude = (length(p) - PLANET_RADIUS) * 1000.0; // km

    float rayleigh_density = exp(-altitude / 8.0);
    float mie_density = exp(-altitude / 1.2);

    rayleigh_scattering = RAYLEIGH_SCATTERING * rayleigh_density;
    float rayleigh_absorption = RAYLEIGH_ABSORPTION * rayleigh_density;

    mie_scattering = MIE_SCATTERING * mie_density;
    float mie_absorption = MIE_ABSORPTION * mie_density;

    vec3 ozone_absorption = OZONE_ABSORPTION * max(0.0, 1.0 - abs(altitude - 25.0) / 15.0);

    extinction = rayleigh_scattering + rayleigh_absorption + mie_scattering + mie_absorption + ozone_absorption;
}
vec3 get_transmittance(vec3 p, vec3 sun_dir) {
    float height = length(p);
    vec3 up = p / height;
    float sun_cos_zenith_angle = dot(sun_dir, up);
    vec2 uv = vec2(
    clamp(0.5 + 0.5 * sun_cos_zenith_angle, 0.0, 1.0),
    max(0.0, min(1.0, (height - PLANET_RADIUS) / (ATMOSPHERE_RADIUS - PLANET_RADIUS)))
    );
    return texture(transmittance_lut, uv).rgb;
}

vec3 angle_to_vector(float theta, float phi) {
    float cp = cos(phi);
    float sp = sin(phi);
    float ct = cos(theta);
    float st = sin(theta);
    return vec3(sp * st, cp, sp * ct);
}
float mie_phase(float cos_theta) {
    const float g = 0.8;
    const float scale = 3.0 / (8.0 * PI);

    float g2 = g*g;
    float numerator = (1.0 - g2) * (1.0 + cos_theta * cos_theta);
    float denominator = (2.0 + g2) * pow((1.0 + g2 - 2.0 * g * cos_theta), 1.5);

    return scale * numerator / denominator;
}
float rayleigh_phase(float cos_theta) {
    float k = 3.0 / (16.0 * PI);
    return k * (1.0 + cos_theta * cos_theta);
}
void multiscatter(vec3 p, vec3 sun_dir, out vec3 net_luminance, out vec3 fms) {
    net_luminance = vec3(0.0);
    fms = vec3(0.0);

    float inverse_samples = 1.0/float(SQRT_SAMPLES * SQRT_SAMPLES);
    for (int i = 0; i < SQRT_SAMPLES; i++) {
        for (int j = 0; j < SQRT_SAMPLES; j++) {
            // symmetric about theta = 0. only integrate from zero to PI, not zero to 2*PI.
            float theta = PI * (float(i) + 0.5) / float(SQRT_SAMPLES);
            float phi = acos(clamp(1.0 - 2.0*(float(j) + 0.5) / float(SQRT_SAMPLES), -1.0, 1.0));
            vec3 d = angle_to_vector(theta, phi);

            float t_atmosphere = intersect_sphere(p, d, ATMOSPHERE_RADIUS);
            float t_ground = intersect_sphere(p, d, PLANET_RADIUS);
            float t_max = t_atmosphere;
            if (t_ground > 0.0) {
                t_max = t_ground;
            }

            float cos_theta = dot(d, sun_dir);

            float mie_phase_value = mie_phase(cos_theta);
            float rayleigh_phase_value = rayleigh_phase(-cos_theta);

            vec3 luminance = vec3(0.0);
            vec3 luminance_factor = vec3(0.0);
            vec3 transmittance = vec3(1.0);
            float t = 0.0;
            for (float step = 0.0; step < STEPS; step += 1.0) {
                float t_new = ((step + 0.3) / STEPS) * t_max;
                float dt = t_new - t;
                t = t_new;

                vec3 sample_p = p + t * d;

                vec3 rayleigh_scattering;
                vec3 extinction;
                float mie_scattering;
                get_scattering_values(sample_p, rayleigh_scattering, mie_scattering, extinction);

                vec3 sample_transmittance = exp(-dt * extinction);

                vec3 scattering_no_phase = rayleigh_scattering + mie_scattering;
                vec3 scattering_f = (scattering_no_phase - scattering_no_phase * sample_transmittance) / extinction;
                luminance_factor += transmittance * scattering_f;

                // might be wrong. from equation 6. "This is slightly different from the paper, but I think the paper has a mistake?" https://www.shadertoy.com/view/slSXRW
                vec3 sun_transmittance = get_transmittance(sample_p, sun_dir);

                vec3 rayleigh_in_scattering = rayleigh_scattering * rayleigh_phase_value;
                float mie_in_scattering = mie_scattering * mie_phase_value;
                vec3 in_scattering = (rayleigh_in_scattering + mie_in_scattering) * sun_transmittance;

                vec3 scattering_integral = (in_scattering - in_scattering * sample_transmittance) / extinction;

                luminance += scattering_integral * transmittance;
                transmittance *= sample_transmittance;
            }

            if (t_ground > 0.0) {
                vec3 sample_p = p + t_ground * d;
                if (dot(p, sun_dir) > 0.0) {
                    sample_p = normalize(sample_p) * PLANET_RADIUS;
                    luminance += transmittance * vec3(0.3) * get_transmittance(sample_p, sun_dir);
                }
            }

            fms += luminance_factor * inverse_samples;
            net_luminance += luminance * inverse_samples;
        }
    }
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);

    vec2 uv = vec2(coord) / imageSize(multiscatter_lut).xy;

    // imageStore(multiscatter_lut, coord.xy, vec4(uv, 0.0, 1.0)); return;

    float sun_cos_theta = 2.0 * uv.x - 1.0;
    float sun_theta = acos(clamp(sun_cos_theta, -1.0, 1.0));
    float height = mix(PLANET_RADIUS, ATMOSPHERE_RADIUS, uv.y);

    vec3 p = vec3(0.0, height, 0.0);
    vec3 sun_dir = normalize(vec3(0.0, sun_cos_theta, -sin(sun_theta)));

    vec3 luminance, f_ms;
    multiscatter(p, sun_dir, luminance, f_ms);

    vec3 psi = luminance  / (1.0 - f_ms);
    imageStore(multiscatter_lut, coord.xy, vec4(psi, 1.0));
}