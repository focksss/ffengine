#version 460

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(set = 0, binding = 0) uniform writeonly image3D high;
layout(set = 0, binding = 1) uniform writeonly image3D low;

const ivec3 offsets[] =
{
ivec3(0,0,0),

ivec3(0,0,1),
ivec3(-1,1,1),
ivec3(-1,0,1),
ivec3(-1,-1,1),
ivec3(0,1,1),
ivec3(0,-1,1),
ivec3(1,1,1),
ivec3(1,0,1),
ivec3(1,-1,1),

ivec3(0,0,-1),
ivec3(-1,1,-1),
ivec3(-1,0,-1),
ivec3(-1,-1,-1),
ivec3(0,1,-1),
ivec3(0,-1,-1),
ivec3(1,1,-1),
ivec3(1,0,-1),
ivec3(1,-1,-1),

ivec3(-1,1,0),
ivec3(-1,0,0),
ivec3(-1,-1,0),
ivec3(0,1,0),
ivec3(0,-1,0),
ivec3(1,1,0),
ivec3(1,0,0),
ivec3(1,-1,0)
};

layout(push_constant) uniform push_constants {
    vec4 r;
    vec4 g;
    vec4 b;
    vec4 a;
    vec4 seeds;
    int is_high;
} constants;

uint hash_u32(uint x) {
    x ^= x >> 16;
    x *= 0x7feb352d;
    x ^= x >> 15;
    x *= 0x846ca68b;
    x ^= x >> 16;
    return x;
}
uvec3 hash_uvec3(uvec3 v) {
    v = v * 1664525u + 1013904223u;
    v.x += v.y * v.z;
    v.y += v.z * v.x;
    v.z += v.x * v.y;
    v ^= v >> 16;
    return v;
}
vec3 hash3(uvec3 cell, uint seed) {
    uvec3 h = hash_uvec3(cell ^ uvec3(seed));
    return vec3(h) * (1.0 / 4294967296.0);
}

float worley(vec3 uvw, int cells_per_axis, uint seed) {
    vec3 position = uvw * float(cells_per_axis);
    ivec3 cell_indices = ivec3(floor(position));
    vec3 cell_offset = fract(position);

    float min_sqr_dist = 1.0;

    for (int i = 0; i < 27; i++) {
        ivec3 neighbor_indices = (cell_indices + offsets[i]);
        ivec3 wrapped_neighbor_indices = ((cell_indices + offsets[i]) % cells_per_axis + cells_per_axis) % cells_per_axis;

        int neighbor_point_index =
        wrapped_neighbor_indices.x +
        wrapped_neighbor_indices.y * cells_per_axis +
        wrapped_neighbor_indices.z * cells_per_axis * cells_per_axis;

        vec3 neighbor_offset = hash3(uvec3(wrapped_neighbor_indices), seed);
        vec3 neighbor_position = vec3(neighbor_indices) + neighbor_offset;

        vec3 delta = neighbor_position - position;
        min_sqr_dist = min(min_sqr_dist, dot(delta, delta));
    }
    return sqrt(min_sqr_dist);
}

float layer(vec4 info, vec3 uvw, int seed) {
    float persistence = info.w;
    float a = worley(uvw, int(info.x), 3 * seed + 0);
    float b = worley(uvw, int(info.y), 3 * seed + 1);
    float c = worley(uvw, int(info.z), 3 * seed + 2);

    float noise_sum = a + (b * persistence) + (c * persistence * persistence);
    float max = 1.0 + (persistence) + (persistence * persistence);

    return noise_sum /= max;
}

void main() {
    ivec3 coord = ivec3(gl_GlobalInvocationID.xyz);
    vec3 uvw = vec3(coord) / imageSize(low);

    if (constants.is_high == 1) {
        uvw = vec3(coord) / imageSize(high);
    }

    vec4 color = vec4(
        layer(constants.r, uvw, int(constants.seeds.r)),
        layer(constants.g, uvw, int(constants.seeds.g)),
        layer(constants.b, uvw, int(constants.seeds.b)),
        layer(constants.a, uvw, int(constants.seeds.a))
    );

    if (constants.is_high == 1) {
        imageStore(high, coord, 1.0 - color);
    } else {
        imageStore(low, coord, 1.0 - color);
    }
}

